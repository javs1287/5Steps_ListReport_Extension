/* eslint-disable camelcase,max-depth */
'use strict';

const xsenv = require('@sap/xsenv');
const NodeCache = require('node-cache');
const destinationUtils = require('./destination-utils');
const tenantDestinationBSCredentialsCache = new NodeCache({stdTTL: 300, checkperiod: 320});
const instanceDestinationBSCredentialsCache = new NodeCache({stdTTL: 300, checkperiod: 320});
const request = require('request');
const url = require('url');

module.exports = {
  getCredentials: function (serviceName, ignoreDots, req) {
    try {
      return xsenv.serviceCredentials(function (service) {
        let vcapSrvServiceName;
        if (service.credentials && service.credentials['sap.cloud.service.alias']) {
          vcapSrvServiceName = ignoreDots ? service.credentials['sap.cloud.service.alias'].replace(/\./g, '') : service.credentials['sap.cloud.service.alias'];
          if (vcapSrvServiceName === serviceName) {
            return true;
          }
        }

        if (service.credentials && service.credentials['sap.cloud.service']) {
          vcapSrvServiceName = ignoreDots ? service.credentials['sap.cloud.service'].replace(/\./g, '') : service.credentials['sap.cloud.service'];
          if (vcapSrvServiceName === serviceName) {
            return true;
          }
        }

        if (service.tags) {
          for (let i = 0; i < service.tags.length; i++) {
            vcapSrvServiceName = ignoreDots ? service.tags[i].replace(/\./g, '') : service.tags[i];
            if (serviceName === vcapSrvServiceName) {
              return true;
            }
          }
        }
        return false;
      });
    } catch (e) {
      return getBSDestination(serviceName, ignoreDots, req);
    }
  },
  cacheBSDestinations: function (req, cb) {
    let tracer = req.loggingContext.getTracer(__filename);
    addDestinationKey(req);
    let destinationBSCredentials = getDestinationBSCredentials(req);
    if (destinationBSCredentials) {
      return cb();
    }
    fetchDestinationBSCredentials(req, tracer, function (err, fetchedBSCredentials) {
      if (err) {
        return cb(err);
      }
      if (req.destinationKey){
        instanceDestinationBSCredentialsCache.set(req.destinationKey,fetchedBSCredentials);
      } else {
        tenantDestinationBSCredentialsCache.set(req.tenant, fetchedBSCredentials);
      }
      return cb();
    });
  },
  getEndPoint: function (serviceCredentials, endPointName) {
    let endPoint = {};
    if (endPointName) {
      if (serviceCredentials.endpoints) {
        if (typeof (serviceCredentials.endpoints[endPointName]) === 'string') {
          endPoint.url = serviceCredentials.endpoints[endPointName] + '/';
        } else if (typeof (serviceCredentials.endpoints[endPointName]) === 'object') {
          endPoint.url = serviceCredentials.endpoints[endPointName].url;
          endPoint.timeout = serviceCredentials.endpoints[endPointName].timeout;
        }
      }
      if (serviceCredentials[endPointName]) {
        if (typeof (serviceCredentials[endPointName]) === 'string') {
          endPoint.url = serviceCredentials[endPointName] + '/';
        } else if (typeof (serviceCredentials[endPointName]) === 'object') {
          endPoint.url = serviceCredentials[endPointName].url;
          endPoint.timeout = serviceCredentials[endPointName].timeout;
        }
      }
    } else {
      endPoint.url = serviceCredentials.url ? serviceCredentials.url + '/' : serviceCredentials.uri + '/';
    }
    endPoint.timeout = endPoint.timeout ? endPoint.timeout : 30000;
    return endPoint;
  },

  getGrantType: function (serviceCredentials) {
    if (serviceCredentials.grant_type) {
      return serviceCredentials.grant_type;
    }
    return 'user_token';
  },
  downloadHTML5Application(req, res) {
    return new Promise((resolve, reject) => {
      const dynamicRoutingUtils = require('./dynamic-routing-utils');
      let appKey = dynamicRoutingUtils.getApplicationKey({url: '/' + url.parse(req.url).path.split('/')[3]});
      let appHostId = null;
      module.exports.getHTML5Applications(req, function (err, html5Applications) {
        if (err) {
          return reject(err);
        } else {
          if (!html5Applications.applications) {
            return reject('No html5 applications found');
          }
          for (let i = 0; i < html5Applications.applications.length; i++) {
            if (html5Applications.applications[i]['sap.cloud.service'].replace(/\./g, '') === appKey.appPrefix &&
              html5Applications.applications[i].applicationName === appKey.appNameWithoutPrefix &&
              html5Applications.applications[i].applicationVersion === appKey.appVersion &&
              ((appKey.appDestinationId && appKey.appDestinationId === html5Applications.applications[i].destinationId) ||
                (!appKey.appDestinationId && !html5Applications.applications[i].destinationId))) {
              appHostId = html5Applications.applications[i]['app-host-id'];
              break;
            }
          }
        }
        if (appHostId === null) {
          return reject('Application ' + appKey.entireKey + ' not found');
        }
        let html5Cred = xsenv.serviceCredentials({tag: 'html5-apps-repo-rt'});
        let requestOptions = {
          url: html5Cred.uri + '/applications/content/' + appKey.appNameWithoutPrefix + '-' + appKey.appVersion,
          headers: {
            'Authorization': 'Bearer ' + req.app.services['html5-apps-repo-rt'].token.accessToken,
            'x-app-host-id': appHostId
          }
        };
        request.get(requestOptions).pipe(res);
      });
    });
  },
  getHTML5Applications(req, cb) {
    let tracer = req.loggingContext.getTracer(__filename);
    fetchDestinationBSCredentials(req, tracer, function (err, destinationBSCredentials) {
      if (err) {
        return cb(err);
      }
      let getApplicationPromises = [];
      if (destinationBSCredentials) {
        for (let sapCloudService in destinationBSCredentials) {
          let cred = destinationBSCredentials[sapCloudService].credentials;
          if (cred['html5-apps-repo'] && cred['html5-apps-repo']['app_host_id']) {
            let appHostIds = cred['html5-apps-repo']['app_host_id'].replace(/\s/g, '').split(',');
            appHostIds.forEach(function (appHostId) {
              let options = {
                appHostId: appHostId,
                sapCloudService: sapCloudService,
                identityZone: cred.uaa && cred.uaa.identityzone ? cred.uaa.identityzone : req.tenant,
                destinationName: cred.destinationName,
                destinationId: cred.destinationId
              };
              getApplicationPromises.push(getApplicationMetadataPromise(req, options));
            });
          }
        }
        Promise.all(getApplicationPromises)
          .then(values => {
            let result = {
              applications: [],
              errors: []
            };
            values.forEach((value) => {
              if (value.applications && value.applications.length > 0) {
                let appArrToMerge = [result.applications, value.applications];
                result.applications = Array.prototype.concat(...appArrToMerge);
              }
              if (value.error) {
                result.errors.push(value.error);
              }
            });
            cb(null, result);
          });
      } else {
        cb(null, {});
      }
    });
  },
};
function fetchDestinationBSCredentials(req,tracer,cb){
  let html5RepoDestinations;
  let destinationBSCredentials = {};
  let tenant = req.tenant;
  getDestinations(req, function(err,destinationsData) {
    if (err) {
      tracer.error('Failed to get destinations by tenant ' + tenant + ' ' + err);
      return cb(err);
    }
    let ownUAACredentials = xsenv.serviceCredentials({label: 'xsuaa'});
    destinationsData.forEach(function (destination) {
      if (destination.hasOwnProperty('sap.cloud.service')) {
        if (destination.hasOwnProperty('app_host_id')) {
          if (!html5RepoDestinations) {
            html5RepoDestinations = {};
          }
          html5RepoDestinations[destination['sap.cloud.service']] = {
            appHostId: destination.app_host_id
          };
        } else {
          let serviceName = destination['sap.cloud.service'];
          destinationBSCredentials[serviceName] = {
            credentials: {
              destinationName: destination.Name,
              serviceName: serviceName
            }
          };
          for (let prop in destination) {
            if (prop === 'html5-apps-repo.app_host_id') {
              destinationBSCredentials[serviceName].credentials['html5-apps-repo'] = {app_host_id: destination[prop]};
            }
            if (prop === 'grant_type' || prop === 'uri' || prop === 'destinationId') {
              destinationBSCredentials[serviceName].credentials[prop] = destination[prop];
            }
            if (prop === 'endpoints' || prop === 'html5-apps-repo') {
              try {
                destinationBSCredentials[serviceName].credentials[prop] = JSON.parse(destination[prop]);
              } catch (err){
                tracer.error('Failed to parse ' + prop + 'property for destination ' + destination.Name + ' ' + err);
                break;
              }
            }
            if (prop.startsWith('endpoints.')) {
              if (!destinationBSCredentials[serviceName].credentials['endpoints']) {
                destinationBSCredentials[serviceName].credentials['endpoints'] = {};
              }
              let parts = prop.split('.');
              if (!destinationBSCredentials[serviceName].credentials['endpoints'][parts[1]]) {
                destinationBSCredentials[serviceName].credentials['endpoints'][parts[1]] = {};
              }
              destinationBSCredentials[serviceName].credentials['endpoints'][parts[1]][parts[2]] = parts[2] === 'timeout' ? parseInt(destination[prop]) : destination[prop];
            }
            if ((prop === 'clientId' || prop === 'clientSecret' || prop === 'tokenServiceURL' || prop === 'tokenServiceURLType'
              || prop === 'xsappname' || prop === 'subaccountId' || prop === 'identityZone' || prop === 'uaaDomain') && !destinationBSCredentials[serviceName].credentials.hasOwnProperty('uaa')) {
              destinationBSCredentials[serviceName].credentials['uaa'] = {};
            }
            if (prop === 'uaaDomain') {
              destinationBSCredentials[serviceName].credentials['uaa']['uaadomain'] = destination[prop];
            }
            if (prop === 'clientId') {
              destinationBSCredentials[serviceName].credentials['uaa']['clientid'] = destination[prop];
              if (!destinationBSCredentials[serviceName].credentials['uaa']['uaadomain']){
                destinationBSCredentials[serviceName].credentials['uaa']['uaadomain'] = ownUAACredentials.uaadomain;
              }
            }
            if (prop === 'subaccountId') {
              destinationBSCredentials[serviceName].credentials['uaa']['subaccountid'] = destination[prop];
            }
            if (prop === 'clientSecret') {
              destinationBSCredentials[serviceName].credentials['uaa']['clientsecret'] = destination[prop];
            }
            if (prop === 'tokenServiceURL') {
              let urlObj = url.parse(destination[prop]);
              destinationBSCredentials[serviceName].credentials['uaa']['url'] = urlObj.protocol + '//' + urlObj.hostname;
              destinationBSCredentials[serviceName].credentials['uaa']['identityzone'] = urlObj.hostname.split('.')[0];
            }
            if (prop === 'xsappname') {
              destinationBSCredentials[serviceName].credentials['uaa'][prop] = destination[prop];
            }
          }
        }
      }
    });
    addAppHostIdData(destinationBSCredentials, html5RepoDestinations);
    cb(null,destinationBSCredentials);
  });
}

function getBSDestination(serviceName, ignoreDots, req) {
  if (!req || !req.tenant){
    return null;
  }
  addDestinationKey(req);
  let destinationBSCredentials = getDestinationBSCredentials(req);
  if (destinationBSCredentials) {
    for (let prop in destinationBSCredentials) {
      let destServiceName = ignoreDots ? prop.replace(/\./g, '') : prop;
      if (destServiceName === serviceName) {
        return destinationBSCredentials[prop].credentials;
      }
    }
  }
  return null;
}

function getDestinationBSCredentials(req){
  function isEmpty(destinationBSCredentials){
    return !destinationBSCredentials ? true : false;
  }
  let destinationBSCredentials = req.destinationKey ? instanceDestinationBSCredentialsCache.get(req.destinationKey) : tenantDestinationBSCredentialsCache.get(req.tenant);
  if (isEmpty(destinationBSCredentials)){
    return null;
  } else {
    return destinationBSCredentials;
  }
}

function getApplicationMetadataPromise(req, options){
  return new Promise((resolve) => {
    let html5Cred = xsenv.serviceCredentials({tag: 'html5-apps-repo-rt'});
    let requestOptions = {
      url: html5Cred.uri + '/applications/metadata/',
      headers: {
        Authorization: 'Bearer ' + req.app.services['html5-apps-repo-rt'].token.accessToken
      }
    };
    requestOptions.headers['x-app-host-id'] = options.appHostId;
    request.get(requestOptions, function onResponse(err, res, body) {
      let result = {};
      if (err || res.statusCode !== 200) {
        result.error = {
          destinationName: options.destinationName,
          sapCloudService: options.sapCloudService,
          appHostId: options.appHostId,
          reason: res && res.body ? res.body : 'Failed to get metadata ' + err
        };
      } else {
        let responseJSON = JSON.parse(body);
        if (responseJSON.length > 0) {
          responseJSON.forEach(function (app) {

            app['sap.cloud.service'] = options.sapCloudService;
            app['identityZone'] = options.identityZone;
            app['app-host-id'] = options.appHostId;
            app['destinationId'] = options.destinationId;
            let host = req.HTML5AppHost.indexOf('https://') !== 0 ? 'https://' + req.HTML5AppHost : req.HTML5AppHost;
            app['url'] = host + '/' + (options.destinationId ? options.destinationId + '.' : '') +
              options.sapCloudService.replace(/\./g, '') + '.' + app.applicationName + '-' + app.applicationVersion;
          });
          result.applications = responseJSON;
        } else {
          result.error = {
            destinationName: options.destinationName,
            sapCloudService: options.sapCloudService,
            appHostId: options.appHostId,
            reason: 'No html5 applications found in App Host'
          };
        }
      }
      resolve(result);
    });
  });
}

function addAppHostIdData(destinationBSCredentials, html5RepoDestinations){
  if (!html5RepoDestinations || !destinationBSCredentials){
    return;
  }
  for (let sapCloudService in html5RepoDestinations) {
    if (destinationBSCredentials[sapCloudService] && destinationBSCredentials[sapCloudService].credentials) {
      destinationBSCredentials[sapCloudService].credentials['html5-apps-repo'] = {app_host_id: html5RepoDestinations[sapCloudService].appHostId};
    }
  }
}

function getDestinations(req,cb){
  if (req.destinationKey) {
    destinationUtils.getDestinationsByDestinationKey(req.app, req.destinationKey, function (err, instanceDestinations) {
      if (err) {
        return cb(err);
      }
      cb(null, instanceDestinations);
    });
  } else if (url.parse(req.url).path.startsWith('/applications')) {
    destinationUtils.getServiceInstanceDestinationsByTenant(req, function(err, instanceDestinations){
      if (err) {
        return cb(err);
      }
      destinationUtils.getDestinationsByTenant(req.tenant, null,function (err, subaccountDestinations) {
        if (err) {
          return cb(err);
        }
        const destinations = instanceDestinations.concat(subaccountDestinations);
        cb(null, destinations);
      });
    });
  } else {
    destinationUtils.getDestinationsByTenant(req.tenant, null,function(err,subaccountDestinations){
      if (err){
        return cb(err);
      }
      cb(null, subaccountDestinations);
    });
  }
}

function addDestinationKey(req){
  const dynamicRoutingUtils = require('./dynamic-routing-utils');
  let appKey = dynamicRoutingUtils.getApplicationKey(req);
  req.destinationKey = appKey && appKey.appDestinationId ? req.tenant + '_' + appKey.appDestinationId : null;
}
